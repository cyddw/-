## 2024-10-22

阅读CSI_Generation_demo

## 2024-10-23

阅读CSI_Generation_demo完毕，尝试理解参数以及整体框架思路

## 2024-10-24

代码时域部分基本完毕，接下来关注频域以及数据的导出

## 2024-10-25

代码部分解析完毕，但是数据导出遇到问题，准备先解读因果发现部分

## 2024-10-26

基本代码库下载完毕，尝试从main函数逐步解读

## 2024-10-27

主要完成tensorboard和visio配置，接下来的计划如下：

1.完成代码部分的整体框架分析以及具体参数值的分析

2.建立四元素因果图测试以及数据预测

3.导出信道模型的数据，并进行测试

## 2024-10-28

整体框架搭建中，下一步继续该步骤

## 2024-10-29

解读预测部分，下一步继续该步骤

## 2024-10-30

代码部分基本解读完毕，后续工作遇到很多问题：

1.对于搭建的四元素模型，测试效果并不好，基本无法学到因果关系，且正确率最高只有70%

2.CSI是复数，而NN一般只能处理实数

## 2024-10-31

1.对于h选取频域还是时延域进行了分析：

最终还是选择频域进行分析

2.对于h、speed、distance、path_gain组成的数据进行分析，尝试其模型性能

3.报错“invalid value encountered in divide”

> 最后确定是因为标准化时，分母std=0

> 尝试不进行标准化处理

4.报错“UserWarning: Detected call of `lr_scheduler.step()` before `optimizer.step()`. In PyTorch 1.1.0 and later, you should call them in” 

> batch_size问题，将其由128改为5

5.运算结果分析：

> 运算准确率只有0.5

> 因果图方面超出预期，前96基本没有因果关系，和理论一样

6.下一步工作：提高准确率，可改进方面：1.从初始因果图着手 2.数据标准化 3.增加T维度的数据 4.增加node数据 5.减少node数据 6.参数优化(epoch、lr...)

7.只保留一个子载波

> 因果图变化不大，准确率变化不大

8.再上述结果的基础上，修改true_cm

> 准确率严重下降，降到0.28

## 2024-11-1

1.探究true_cm在代码中起到的作用

2.尝试对calc_and_log_metrics的阈值进行修改看是否能改善AUC

> 将阈值由0.5改为0.3 AUC=0.2817，AUC没有变化，为什么？

> AUC的取值与阈值无关

3.因果发现部分是如何运行的？

> ![image](https://github.com/user-attachments/assets/7552dcb4-6b75-431c-badf-d9b6e34497ac)

4.AUC取值为什么与阈值无关？

> 查询资料可知，AUC取值与阈值无关，详情可见[CSDN](https://blog.csdn.net/pearl8899/article/details/109829306)

5.源代码中，AUC和ACC取值都接近1，而自身代码AUC为0.28，而ACC为0.9，为什么？

> [CSDN](https://blog.csdn.net/Jessica__Chan/article/details/104492761)

6.经过探究，现在可以回答1问题，true_cm就是假定的真实因果图，而训练得到的graph越接近true_cm，则AUC越大，说明模型越符合实际，而训练得到的graph和true_cm之间并无关系，也就是说，若要提高AUC，可以将true_cm尽量向graph靠(??)

7.可否不考虑AUC，只考虑ACC？

> 对于ACC为什么高这个问题，是因为，graph在迭代后期值很小，取阈值后，全为false，而true_cm的true占比又小，所以ACC高

> 综合考虑，还是得考虑AUC，ACC其实不用担心，一定是高的

8.问题还是回到如何提高AUC？

> 回到原来的96个子载波状态

9.尝试改变true_cm，让27个因素作为96个子载波的因

## 2024-11-2

1.当改变true_cm，令i>95，j<96为1时，ACC下降到0.85，AUC上升0.75

2.当改变true_cm，令i>95，j>95，ACC和AUC均显著上升至0.95

3.当尝试增加T，将其由20增大至100，所得的graph的趋势更明显，即i>95，j>95部分有强烈的因果

> 事实上，这并不是我们所期待的结果，我们希望，i>95，j<96处有强烈的因果

> 同时，发现一个问题，当改变T至100时，path_gain也随之改变，且H的前20个也变化

4.尝试对上述所提及的问题进行探究

> 在调试过程中发现，在不同的shot下，同一路径的时延不变，那么gain也就不变

> 针对上面这个问题，改变采样间隔由e-3至e-2，speed*10zhin

> 尽管增加100倍，但是时延仍然不变，保留间隔为e-2，speed回到原来大小

5.对于data，每次用matlab重新运行，所得数据结果会改变，且对AUC有较大影响

6.尝试增加不同的数据集，即控制变量，以获得不同的数据

> 接下来尝试产生10个NUM

## 2024-11-3

1.增加10个NUM后，graph并没有发生显著改变，反而i>95和j>95的部分的因果关系更加强烈

2.尝试修正true_cm，使得AUC和ACC尽量大

> 当i>95,j<96以及i<96,j>95部分的因果为1时，其AUC并没有显著上升，仍为0.75左右

3.尝试改变seed

> 当seed取2时，AUC为0.75

> 当seed取3时，AUC显著下降为0.5

> 当seed取4时，AUC仍然为0.5

4.尝试从源代码本质出发，即寻找生成H的变量，将变量提取出来作为node

## 2024-11-4

## 2024-11-5

## 2024-11-6

成功获得想要的结果，结束
## 2024-11-16

> 
















































